# PRIMARY CONTROL - MAZAK-VQC1540 mill
# Author: Timothy Snowden / Solid Rock Development
#         (begun with 5i25/7i77 configuration by PNCConf)
# !!! DO NOT MODIFY WITH PNCCONF - FILE WILL BE RUINED !!!
# NOTES:
# - Spindle-control in spindle.hal
# - Tool-change (ATC) in atc.hal
# - PLC (ClassicLadder) connections in plc.hal
# - GUI-dependent connections in postgui.hal

#=============================
# MODULES/FUNCTIONS
#=============================
#-------------------
# LOAD MODULES
#-------------------
# Trivial Kinematics module (1:1 correspondence between joints & axes)
loadrt [KINS]KINEMATICS
#autoconverted  trivkins

# EMC Motion control module - servo period freq & # of joints
loadrt [EMCMOT]EMCMOT servo_period_nsec=[EMCMOT]SERVO_PERIOD num_joints=[KINS]JOINTS num_dio=[EMCMOT]NUM_DIO num_aio=[EMCMOT]NUM_AIO 

# Mesa Driver - generic (hostmot2)
loadrt hostmot2
# Mesa Driver - Anything I/O board specific (eth, 7i80)
# sserial_port config:
# - 7i80 - Anything I/O Board --> not a serial port
# - 7i49 - Resolver/Analog Servo Board --> not a serial port
# - 7i44 - Ethernet Connection Board --> serial port #0 (8 channels)
# - 7i84 - GPIO Board --> channels 0 & 1 (two boards)
#    * 0: I/O only
#    * 1: I/O + VFieldIn + Ain x 4 (analog channels0...3)
#    * 2: I/O + VFieldIn + Ain x 4 + MPG Encoder x2 (inputs 16...19)
# - 7i73 - Pendant/Remote Interface -->  channel 2
#    * 0: I/O + encoder
#    * 1: I/O + encoder + Ain
#    * 2: I/O + encoder + Ain fast display
# Choose mode PER CHANNEL (= per board)
# x = disabled (which defaults to GPIO if available)
loadrt hm2_eth board_ip="192.168.1.121" config="num_resolvers=6 num_encoders=0 num_pwmgens=6 num_stepgens=0 sserial_port_0=000xxx"

# PID Realtime Loop Component - axis x, y, & z
loadrt pid names=pid.x,pid.y,pid.z,pid.s

loadrt estop_latch

# logic.0 used to release Z brake when both Z servo PWN is active and
# motion.motion-enabled is true
# logic.1 used to enable the lube and hydraulic system when needed
# logic.2 used to turn on power-on when starting linuxcnc
loadrt logic count=3 personality=0x101,0x202,0x202

loadrt lut5 names=tool-mag-jog-button,tool-mag-movable



#-------------------
# LOAD MODULES
#-------------------
# Set watchdog timer
setp    hm2_7i80.0.watchdog.timeout_ns 5000000

#-------------------
# LOAD FUNCTIONS
#-------------------
# Every servo thread cycle:

# - Read the 7i80 pins:
addf hm2_7i80.0.read          servo-thread

addf estop-latch.0            servo-thread

addf logic.0            servo-thread
addf logic.1            servo-thread
addf logic.2            servo-thread

addf tool-mag-jog-button      servo-thread
addf tool-mag-movable         servo-thread

# - Motion command handler:
addf motion-command-handler   servo-thread

# - Motion controller:
addf motion-controller        servo-thread

# - Update the PID calculations for the:
#   * X-axis:
addf pid.x.do-pid-calcs       servo-thread
#   * Y-axis:
addf pid.y.do-pid-calcs       servo-thread
#   * Z-axis:
addf pid.z.do-pid-calcs       servo-thread

# - Write out new values to the 7i80 pins every servo-thread cycle:
addf hm2_7i80.0.write         servo-thread


#=============================
# SIGNALS
#=============================
# NOTE:
# - All spindle signals, etc in 'spindle.hal'
# - All toolchange signals, etc in 'atc.hal'
# - All connections in/out of PLC in 'plc.hal'
# - All connections relying on GUI in 'postgui.hal'

# MESA NAMING SCHEME NOTES:
# Current understanding of naming scheme for daughter I/O boards:
# hm2_<FPGA-board>.<FPGA-board-number>.<daughter-board>.<serial-port-number>.<serial-channel-number>.<input-or-output>-<pin-number>
# Example: hm2_7i80.0.7i84.0.1.input-00
# - FPGA-board = 7i80 (main board connecting to computer)
# - FPGA-board-number = 0 (1st one ... MOST configurations only have one)
# - daughter-board = 7i84
# - serial-port-number = 0 (1st serial port. Only have one in this configuration ... the 7i44)
# - serial-channel-number = 1 (1st channel of 8 potential ones FOR THIS SERIAL PORT, as there are 8 channels on the 7i44. We are only using 0 & 1 right now for the two 7i84s)
# - input-or-output = an input, so put 'input' (and use 'output' for an output...)
# - pin-number = the given pin number, starting with 00, numbered for the BOARD, not the connector. See given manual for numbering.


#-------------------
# EXTERNAL SIGNALS - inputs to LinuxCNC from the machine
#-------------------

net spindle-zero-speed         <= hm2_7i80.0.7i84.0.0.input-00
net spindle-controller-normal  <= hm2_7i80.0.7i84.0.0.input-01
net spindle-orient-arrival     <= hm2_7i80.0.7i84.0.0.input-02
net spindle-tool-detector      <= hm2_7i80.0.7i84.0.0.input-03
net tool-mag-door-interlock    <= hm2_7i80.0.7i84.0.0.input-04
#net ???                        <= hm2_7i80.0.7i84.0.0.input-05
#net magazine-cover-open        <= hm2_7i80.0.7i84.0.0.input-06
#net magazine-cover-closed      <= hm2_7i80.0.7i84.0.0.input-07
#net ???                        <= hm2_7i80.0.7i84.0.0.input-08
#net ???                        <= hm2_7i80.0.7i84.0.0.input-09
#net ???                        <= hm2_7i80.0.7i84.0.0.input-10
#net ???                        <= hm2_7i80.0.7i84.0.0.input-11
#net ???                        <= hm2_7i80.0.7i84.0.0.input-12
#net ???                        <= hm2_7i80.0.7i84.0.0.input-13
#net ???                        <= hm2_7i80.0.7i84.0.0.input-14
#net ???                        <= hm2_7i80.0.7i84.0.0.input-15
net tool-mag-in-position       <= hm2_7i80.0.7i84.0.0.input-16
net tool-mag-position-1        <= hm2_7i80.0.7i84.0.0.input-17
net tool-mag-position-2        <= hm2_7i80.0.7i84.0.0.input-18
net tool-mag-position-4        <= hm2_7i80.0.7i84.0.0.input-19
net tool-mag-position-8        <= hm2_7i80.0.7i84.0.0.input-20
net magazine-button            <= hm2_7i80.0.7i84.0.0.input-21
net tool-mag-cover-open        <= hm2_7i80.0.7i84.0.0.input-22
net tool-mag-cover-closed      <= hm2_7i80.0.7i84.0.0.input-23
net tool-mag-position-16       <= hm2_7i80.0.7i84.0.0.input-24
net tool-measure-lower-switch  <= hm2_7i80.0.7i84.0.0.input-25
net tool-measure-upper-switch  <= hm2_7i80.0.7i84.0.0.input-26
net tool-measure-arm-extended  <= hm2_7i80.0.7i84.0.0.input-27
net tool-measure-arm-retracted <= hm2_7i80.0.7i84.0.0.input-28
net tool-mag-tool-detector     <= hm2_7i80.0.7i84.0.0.input-29
net tool-unclamped             <= hm2_7i80.0.7i84.0.0.input-30
net tool-clamped               <= hm2_7i80.0.7i84.0.0.input-31

#net machine-power-supply-on    <= hm2_7i80.0.7i84.0.1.input-00
#net thermal-protector-tripped  <= hm2_7i80.0.7i84.0.1.input-01
#net main-transformer-overheat  <= hm2_7i80.0.7i84.0.1.input-02
#net head-lube-pressure-alarm   <= hm2_7i80.0.7i84.0.1.input-03
#net head-lube-pressure-alarm2  <= hm2_7i80.0.7i84.0.1.input-04
#net way-lube-alarm             <= hm2_7i80.0.7i84.0.1.input-05
#net ???                        <= hm2_7i80.0.7i84.0.1.input-06
#net ???                        <= hm2_7i80.0.7i84.0.1.input-07
net machine-door-interlock     <= hm2_7i80.0.7i84.0.1.input-08
#net ???                        <= hm2_7i80.0.7i84.0.1.input-09
#net ???                        <= hm2_7i80.0.7i84.0.1.input-10
#net ???                        <= hm2_7i80.0.7i84.0.1.input-11
#net ???                        <= hm2_7i80.0.7i84.0.1.input-12
#net ???                        <= hm2_7i80.0.7i84.0.1.input-13
#net ???                        <= hm2_7i80.0.7i84.0.1.input-14
#net ???                        <= hm2_7i80.0.7i84.0.1.input-15
net x-home-switch              <= hm2_7i80.0.7i84.0.1.input-16-not
net y-home-switch              <= hm2_7i80.0.7i84.0.1.input-17-not
net z-home-switch              <= hm2_7i80.0.7i84.0.1.input-18-not
net x-pos-limit-switch         <= hm2_7i80.0.7i84.0.1.input-19-not
net x-neg-limit-switch         <= hm2_7i80.0.7i84.0.1.input-20-not
net y-pos-limit-switch         <= hm2_7i80.0.7i84.0.1.input-21-not
net y-neg-limit-switch         <= hm2_7i80.0.7i84.0.1.input-22-not
net z-pos-limit-switch         <= hm2_7i80.0.7i84.0.1.input-23-not
net z-neg-limit-switch         <= hm2_7i80.0.7i84.0.1.input-24-not
#net ???                        <= hm2_7i80.0.7i84.0.1.input-25
#net ???                        <= hm2_7i80.0.7i84.0.1.input-26
net feed-hold-button           <= hm2_7i80.0.7i84.0.1.input-27
net machine-estop-ok           <= hm2_7i80.0.7i84.0.1.input-28
net servo-x-drive-alarm        <= hm2_7i80.0.7i84.0.1.input-29
net servo-y-drive-alarm        <= hm2_7i80.0.7i84.0.1.input-30
net servo-z-drive-alarm        <= hm2_7i80.0.7i84.0.1.input-31


#-------------------
# EXTERNAL SIGNALS - outputs from LinuxCNC to the machine
#-------------------

# Enable spindle drive
net spindle-set                => hm2_7i80.0.7i84.0.0.output-00
net spindle-set                => hm2_7i80.0.pwmgen.03.enable

# Spindle forward/reverse commands (requires spindle-run for spindle to activate)
net spindle-reverse            => hm2_7i80.0.7i84.0.0.output-01
net spindle-forward            => hm2_7i80.0.7i84.0.0.output-02
net spindle-run                => hm2_7i80.0.7i84.0.0.output-03
net spindle-air-blast          => hm2_7i80.0.7i84.0.0.output-04
net spindle-fan                => hm2_7i80.0.7i84.0.0.output-05
#net ???                        => hm2_7i80.0.7i84.0.0.output-06
#net ???                        => hm2_7i80.0.7i84.0.0.output-07
net magazine-run               => hm2_7i80.0.7i84.0.0.output-08
net orient-command             => hm2_7i80.0.7i84.0.0.output-09
net magazine-cw-reverse        => hm2_7i80.0.7i84.0.0.output-10
net magazine-ccw-forward       => hm2_7i80.0.7i84.0.0.output-11
net magazine-cover-close       => hm2_7i80.0.7i84.0.0.output-12
net tool-change-release-limits => hm2_7i80.0.7i84.0.0.output-13
net tool-unclamp               => hm2_7i80.0.7i84.0.0.output-14
net tool-measuring-arm-extend  => hm2_7i80.0.7i84.0.0.output-15

#net servo-x-off                => hm2_7i80.0.7i84.0.1.output-00
#net servo-y-off                => hm2_7i80.0.7i84.0.1.output-01
#net servo-z-off                => hm2_7i80.0.7i84.0.1.output-02
net z-brake-release            => hm2_7i80.0.7i84.0.1.output-03 # this pin activates ABRK, which releases the Z brake
net work-light                 => hm2_7i80.0.7i84.0.1.output-04
net hydraulic-lube-pump-on     => hm2_7i80.0.7i84.0.1.output-05
net flood-coolant-motor-on     => hm2_7i80.0.7i84.0.1.output-06
net power-on                   => hm2_7i80.0.7i84.0.1.output-07
#net ???                        => hm2_7i80.0.7i84.0.1.output-08
net servo-on                   => hm2_7i80.0.7i84.0.1.output-09 # this pin activates the X servo as well as ready all three servos
net servo-on                   => hm2_7i80.0.pwmgen.00.enable
#net ???                        => hm2_7i80.0.7i84.0.1.output-10
net servo-on                   => hm2_7i80.0.7i84.0.1.output-11 # this pin activates the Y servo

net servo-on                   => hm2_7i80.0.pwmgen.01.enable
#net ???                        => hm2_7i80.0.7i84.0.1.output-12
net servo-on                 => hm2_7i80.0.7i84.0.1.output-13 # this pin activates the Z servo
net servo-on                 => hm2_7i80.0.pwmgen.02.enable

# Enable axis servos when (|) "Machine power" button is pressed
net servo-on                   <= motion.motion-enabled

# Only release Z axis brake when Z is both ready and on
# FIXME Note, net servo-on is standin for motion.motion-enabled
net servo-on                   => logic.0.in-00
net z-brake-release            <= logic.0.and

# Enable hydraulic and way lubrication pump when servos are enabled
net lube-wanted                <= iocontrol.0.lube
net lube-wanted                => logic.1.in-00
net servo-on                   => logic.1.in-01
net hydraulic-lube-pump-on     <= logic.1.or

net overtravel-release         => hm2_7i80.0.7i84.0.1.output-14
# Axis GUI only have one setting for joint 0-2, arbitrary picking 0
net overtravel-release         <= halui.joint.0.override-limits

#net ???                        => hm2_7i80.0.7i84.0.1.output-15

#=============================
# AXIS SETUP
#=============================
# Set resolver excitation frequency (same for all axes)
setp hm2_7i80.0.resolver.excitation-khz [AXES]RESOLVER_EXC_FREQ

#-------------------
# AXIS-X
#-------------------
# Servo Enable Command
net servo-x-enable		<=	joint.0.amp-enable-out

# Set PID-loop Parameters (from .ini file variables):
setp   pid.x.Pgain     [JOINT_0]P
setp   pid.x.Igain     [JOINT_0]I
setp   pid.x.Dgain     [JOINT_0]D
setp   pid.x.bias      [JOINT_0]BIAS
setp   pid.x.FF0       [JOINT_0]FF0
setp   pid.x.FF1       [JOINT_0]FF1
setp   pid.x.FF2       [JOINT_0]FF2
setp   pid.x.deadband  [JOINT_0]DEADBAND
setp   pid.x.maxoutput [JOINT_0]MAX_OUTPUT
setp   pid.x.error-previous-target true
setp   pid.x.maxerror  [JOINT_0]MAX_ERROR

# Connect Virtual Pins to X-axis PID Loop:
net x-index-enable	=>	pid.x.index-enable
net servo-x-enable     	=>	pid.x.enable
net x-pos-cmd        	=>	pid.x.command
net x-vel-cmd        	=>	pid.x.command-deriv
net x-pos-fb         	=>	pid.x.feedback
net x-output         	<=	pid.x.output


# AXIS SERVO DRIVE / AMPLIFIER FAULT (from PLC)
net plc-servo-x-drive-alarm	=>	joint.0.amp-fault-in


# PWM GENERATOR SETUP

setp hm2_7i80.0.pwmgen.pwm_frequency 24000

# Set PWMGen type for 7i49 (2 = up/down) - x-axis
setp hm2_7i80.0.pwmgen.00.output-type			2

# Set x-axis PWMGen scale - from .ini file
setp hm2_7i80.0.pwmgen.00.scale  			[JOINT_0]OUTPUT_SCALE

# Connect Signals:
# - Analog servo drive command signal to Mesa board analog-out
net x-output  			=>	hm2_7i80.0.pwmgen.00.value
# - Commanded-position from internal axis module
net x-pos-cmd 			<=	joint.0.motor-pos-cmd


# RESOLVER FEEDBACK SIGNALS/SETUP
# Set Parameters from .ini File Variables:
# - Index-divisor: number of cycles per rev of the resolver (used to generate an emulated index)
setp hm2_7i80.0.resolver.00.index-divisor		[JOINT_0]RESOLVER_INDEX_DIVISOR
# - Position scale, in machine units per resolver electrical revolution
setp hm2_7i80.0.resolver.00.scale  				[JOINT_0]RESOLVER_SCALE
# -  Conversion factor between resolver rotation speed and machine velocity
setp hm2_7i80.0.resolver.00.velocity-scale		[JOINT_0]RESOLVER_VELOCITY_SCALE

# Connect Signals:
# - Position feedback from Mesa board
net x-pos-fb			<=	hm2_7i80.0.resolver.00.position
# - Velocity feedback from Mesa board
net x-vel-fb			<=	hm2_7i80.0.resolver.00.velocity
# - Position feedback to internal axis module
net x-pos-fb			=>	joint.0.motor-pos-fb
# - Index enable (reset position & count pins every time resolver passes through 0 position)
net x-index-enable 			joint.0.index-enable  <=>  hm2_7i80.0.resolver.00.index-enable
# - Counts (simulated encoder count at 2^24 counts per rev = 16777216 counts, but not reset by 'index' or 'reset' pins)
net x-pos-rawcounts		<=	hm2_7i80.0.resolver.00.rawcounts

# HOME/LIMIT-SWITCH SIGNAL SETUP
net x-home-switch      => joint.0.home-sw-in
net x-neg-limit-switch => joint.0.neg-lim-sw-in
net x-home-switch      => joint.0.pos-lim-sw-in

# Homing Signal:
net x-homing			<=	joint.0.homing

#-------------------
# AXIS-Y
#-------------------
# Servo Enable Command
net servo-y-enable		<=	joint.1.amp-enable-out

# Set PID-loop Parameters (from .ini file variables):
setp   pid.y.Pgain     [JOINT_1]P
setp   pid.y.Igain     [JOINT_1]I
setp   pid.y.Dgain     [JOINT_1]D
setp   pid.y.bias      [JOINT_1]BIAS
setp   pid.y.FF0       [JOINT_1]FF0
setp   pid.y.FF1       [JOINT_1]FF1
setp   pid.y.FF2       [JOINT_1]FF2
setp   pid.y.deadband  [JOINT_1]DEADBAND
setp   pid.y.maxoutput [JOINT_1]MAX_OUTPUT
setp   pid.y.error-previous-target true
setp   pid.y.maxerror  [JOINT_1]MAX_ERROR

# Connect Virtual Pins to Y-axis PID Loop:
net y-index-enable	=>	pid.y.index-enable
net servo-y-enable     	=>	pid.y.enable
net y-pos-cmd        	=>	pid.y.command
net y-vel-cmd        	=>	pid.y.command-deriv
net y-pos-fb         	=>	pid.y.feedback
net y-output         	<=	pid.y.output


# AXIS SERVO DRIVE / AMPLIFIER FAULT (from PLC)
net plc-servo-y-drive-alarm	=>	joint.1.amp-fault-in


# PWM GENERATOR SETUP
# Set PWMGen type for 7i49 (2 = up/down) - y-axis
setp hm2_7i80.0.pwmgen.01.output-type	 		2

# Set y-axis PWMGen scale - from .ini file
setp hm2_7i80.0.pwmgen.01.scale  			[JOINT_1]OUTPUT_SCALE

# Connect Signals:
# - Analog servo drive command signal to Mesa board analog-out
net y-output  			=>	hm2_7i80.0.pwmgen.01.value
# - Commanded-position to internal axis module
net y-pos-cmd 			<=	joint.1.motor-pos-cmd


# RESOLVER FEEDBACK SIGNALS/SETUP
# Set Parameters from .ini File Variables:
# - Index-divisor: number of cycles per rev of the resolver (used to generate an emulated index)
setp hm2_7i80.0.resolver.01.index-divisor 		[JOINT_1]RESOLVER_INDEX_DIVISOR
# - Position scale, in machine units per resolver electrical revolution
setp hm2_7i80.0.resolver.01.scale  				[JOINT_1]RESOLVER_SCALE
# -  Conversion factor between resolver rotation speed and machine velocity
setp hm2_7i80.0.resolver.01.velocity-scale 		[JOINT_1]RESOLVER_VELOCITY_SCALE

# Connect Signals:
# - Position feedback from Mesa board
net y-pos-fb			<=	hm2_7i80.0.resolver.01.position
# - Velocity feedback from Mesa board
net y-vel-fb			<=	hm2_7i80.0.resolver.01.velocity
# - Position feedback to internal axis module
net y-pos-fb			=>	joint.1.motor-pos-fb
# - Index enable (reset position & count pins every time resolver passes through 0 position)
net y-index-enable joint.1.index-enable  <=>  hm2_7i80.0.resolver.01.index-enable
# - Counts (simulated encoder count at 2^24 counts per rev = 16777216 counts, but not reset by 'index' or 'reset' pins)
net y-pos-rawcounts		<=	hm2_7i80.0.resolver.01.rawcounts

# HOME/LIMIT-SWITCH SIGNAL SETUP
net y-home-switch      => joint.1.home-sw-in
net y-neg-limit-switch => joint.1.neg-lim-sw-in
net y-pos-limit-switch => joint.1.pos-lim-sw-in

# Homing Signal:
net y-homing			<=	joint.1.homing


#-------------------
# AXIS-Z
#-------------------
# Servo Enable Command
net servo-z-enable		<=	joint.2.amp-enable-out

# Set PID-loop Parameters (from .ini file variables):
setp   pid.z.Pgain     [JOINT_2]P
setp   pid.z.Igain     [JOINT_2]I
setp   pid.z.Dgain     [JOINT_2]D
setp   pid.z.bias      [JOINT_2]BIAS
setp   pid.z.FF0       [JOINT_2]FF0
setp   pid.z.FF1       [JOINT_2]FF1
setp   pid.z.FF2       [JOINT_2]FF2
setp   pid.z.deadband  [JOINT_2]DEADBAND
setp   pid.z.maxoutput [JOINT_2]MAX_OUTPUT
setp   pid.z.error-previous-target true
setp   pid.z.maxerror  [JOINT_2]MAX_ERROR

# Connect Virtual Pins to Z-axis PID Loop:
net z-index-enable	=>	pid.z.index-enable
net servo-z-enable	=>	pid.z.enable
net z-pos-cmd   	=>	pid.z.command
net z-vel-cmd       	=>	pid.z.command-deriv
net z-pos-fb        	=>	pid.z.feedback
net z-output        	<=	pid.z.output


# AXIS SERVO DRIVE / AMPLIFIER FAULT (from PLC)
net plc-servo-z-drive-alarm	=>	joint.2.amp-fault-in


# PWM GENERATOR SETUP
# Set PWMGen type for 7i49 (2 = up/down) - z-axis
setp hm2_7i80.0.pwmgen.02.output-type			2

# Set z-axis PWMGen scale - from .ini file
setp hm2_7i80.0.pwmgen.02.scale  			[JOINT_2]OUTPUT_SCALE

# Connect Signals:
# - Analog servo drive command signal to Mesa board analog-out
net z-output  			=>	hm2_7i80.0.pwmgen.02.value
# - Commanded-position to internal axis module
net z-pos-cmd 			=>	joint.2.motor-pos-cmd


# RESOLVER FEEDBACK SIGNALS/SETUP
# Set Parameters from .ini File Variables:
# - Index-divisor: number of cycles per rev of the resolver (used to generate an emulated index)
setp hm2_7i80.0.resolver.02.index-divisor 		[JOINT_2]RESOLVER_INDEX_DIVISOR
# - Position scale, in machine units per resolver electrical revolution
setp hm2_7i80.0.resolver.02.scale  				[JOINT_2]RESOLVER_SCALE
# -  Conversion factor between resolver rotation speed and machine velocity
setp hm2_7i80.0.resolver.02.velocity-scale 		[JOINT_2]RESOLVER_VELOCITY_SCALE

# Connect Signals:
# - Position feedback from Mesa board
net z-pos-fb			<=	hm2_7i80.0.resolver.02.position
# - Velocity feedback from Mesa board
net z-vel-fb			<=	hm2_7i80.0.resolver.02.velocity
# - Position feedback to internal axis module
net z-pos-fb			=>	joint.2.motor-pos-fb
# - Index enable (reset position & count pins every time resolver passes through 0 position)
net z-index-enable joint.2.index-enable  <=>  hm2_7i80.0.resolver.02.index-enable
# - Counts (simulated encoder count at 2^24 counts per rev = 16777216 counts, but not reset by 'index' or 'reset' pins)
net z-pos-rawcounts		<=	hm2_7i80.0.resolver.02.rawcounts

# HOME/LIMIT-SWITCH SIGNAL SETUP
net z-home-switch      => joint.2.home-sw-in
net z-neg-limit-switch => joint.2.neg-lim-sw-in
net z-home-switch      => joint.2.pos-lim-sw-in

# Homing Signal:
net z-homing			<=	joint.2.homing

#=============================
# INTERNAL SIGNALS
#=============================
#-------------------
# HALUI MODULE SIGNALS
#-------------------
# Joints-to-Axes
# - X-axis
net joint-select-a		=>	halui.axis.x.select
net x-is-homed			<=	halui.joint.0.is-homed
net jog-x-pos             halui.axis.x.plus
net jog-x-neg             halui.axis.x.minus
net jog-x-analog          halui.axis.x.analog

# - Y-axis
net joint-select-b        halui.axis.y.select
net y-is-homed            halui.joint.1.is-homed
net jog-y-pos             halui.axis.y.plus
net jog-y-neg             halui.axis.y.minus
net jog-y-analog          halui.axis.y.analog

# - Z-axis
net joint-select-c        halui.axis.z.select
net z-is-homed            halui.joint.2.is-homed
net jog-z-pos             halui.axis.z.plus
net jog-z-neg             halui.axis.z.minus
net jog-z-analog          halui.axis.z.analog

# MDI/Jogging
net MDI-mode			<=	halui.mode.is-mdi
net jog-selected-pos		<=	halui.axis.selected.plus
net jog-selected-neg		<=	halui.axis.selected.minus
net jog-speed			<=	halui.axis.jog-speed 


#-------------------
# IOCONTROL MODULE SIGNALS
#-------------------
# Coolant
net coolant-mist  		<=	iocontrol.0.coolant-mist
net coolant-flood 		<=	iocontrol.0.coolant-flood

# Enable / ESTOP:
# For ladder based ESTOP
#net plc-estop                  =>      iocontrol.0.emc-enable-in
# Use simple estop_latch based ESTOP handling for now
net machine-estop-ok            =>      estop-latch.0.ok-in
net estop-reset                 =>      estop-latch.0.reset
net estop-ok                    <=      estop-latch.0.ok-out
net estop-reset                 <=      iocontrol.0.user-request-enable
net estop-ok                    =>      iocontrol.0.emc-enable-in
net estop-out                   <=      iocontrol.0.user-enable-out

# See atc.hal for tool-change related IOCONTROL signals

# PROBE SIGNAL
net probe-in 			=>	motion.probe-input

#-------------------
# MOTION MODULE SIGNALS
#-------------------
# Feed hold
net feed-hold			=> motion.feed-hold

#-------------------
# Tool changer carousel
#-------------------
loadrt   carousel   pockets=30  encoding=binary  num_sense=5 dir=1
addf carousel.0 servo-thread
net tool-mag-position-1  => carousel.0.sense-0
net tool-mag-position-2  => carousel.0.sense-1
net tool-mag-position-4  => carousel.0.sense-2
net tool-mag-position-8  => carousel.0.sense-3
net tool-mag-position-16 => carousel.0.sense-4
net tool-mag-in-position => carousel.0.strobe
net magazine-ccw-forward <= carousel.0.motor-fwd

# Block magazine from moving automatically when eject door is open
# Only allow to move while manual jog button is pressed when door is
# open.
setp tool-mag-movable.function 0xa8a8a8a8 # in-0 and in-1
net tool-mag-enabled           <= carousel.0.active
net tool-mag-enabled           => tool-mag-movable.in-0
net tool-mag-door-interlock    => tool-mag-movable.in-1
net magazine-button            => tool-mag-movable.in-2
net magazine-run               <= tool-mag-movable.out

# Only allow manual magazine forward jog button to work in manual and mdi mode
setp tool-mag-jog-button.function 0x22222222 # in-0 and not in-1
net magazine-button            => tool-mag-jog-button.in-0
net is-auto-mode               => tool-mag-jog-button.in-1
net tool-mag-manual-jog        <= tool-mag-jog-button.out
net tool-mag-manual-jog        => carousel.0.jog-fwd

# Set pocket-number to wanted tool pocked, then enable to true and
# wait for ready to go true, then enable to false
net tool-prep-number      => carousel.0.pocket-number
net tool-prep-number      <= iocontrol.0.tool-prep-pocket
net tool-prepare          => carousel.0.enable
net tool-prepare          <= iocontrol.0.tool-prepare
net tool-prepared         <= carousel.0.ready
net tool-prepared         => iocontrol.0.tool-prepared

#-------------------
# MISC CONNECTIONS
#-------------------

# Turn power-on true when linuxcnc starts
net power-on                => logic.2.in-00
net machine-estop-ok        => logic.2.in-01
net power-on                <= logic.2.or
